| Task               | Command                           | Notes                                        |
| ------------------ | --------------------------------- | -------------------------------------------- |
| **Show databases** | âŒ *Not supported*                 | SQLite is file-based, so no `SHOW DATABASES` |
| **Create DB**      | `sqlite3 mydb.db`                 | Done at launch (creates file)                |
| **Show tables**    | `.tables`                         | Lists all tables                             |
| **Show schema**    | `.schema` or `.schema table_name` | Shows table structure                        |
| **Create table**   | See below                         | Standard SQL                                 |
| **List commands**  | `.help`                           | Lists SQLite-specific commands               |
| **Exit SQLite**    | `.exit` or `.quit`                | Ends session                                 |


Department = > id:pk ,name
Employee => id:pk,name,email,salary_grade:fk,dep_id:fk
Salary=>id:pk,salary

.mode column
.headers on
PRAGMA foreign_keys = ON;

CREATE TABLE Employee (
    emp_id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    grade TEXT CHECK (grade IN ('A', 'B', 'C')),
    dept_id INTEGER,
    FOREIGN KEY (grade) REFERENCES Salary(grade),
    FOREIGN KEY (dept_id) REFERENCES Department(dept_id)
);
CREATE TABLE Salary (
    grade TEXT PRIMARY KEY CHECK (grade IN ('A', 'B', 'C')),
    base_salary REAL NOT NULL
);
CREATE TABLE Department (
    dept_id INTEGER PRIMARY KEY,
    dept_name TEXT NOT NULL
);

## queries
SELECT name, grade FROM Employee WHERE dept_id = 2;
SELECT name AS 'Employee Name', grade AS 'Grade Level' FROM Employee;
SELECT DISTINCT grade FROM Employee; // only grade col with unique values

# Normalization
Normalization is the process of organizing data in a database to:
Reduce data redundancy
Avoid anomalies in insert/update/delete
Ensure data integrity

ğŸ”¹ Why Normalize?
Imagine if an employeeâ€™s department name was stored directly in the Employee table:
emp_id | name   | dept_name
-------|--------|----------
1      | Alice  | HR
2      | Bob    | HR
3      | Charlie| Sales
Now if the HR department changes name to â€œPeople Opsâ€, youâ€™d have to update 
it in every row manually. If you forget one, your data is inconsistent.
Normalization solves this by splitting related data into separate tables.


1NF: First Normal Form
Rule: Each cell must hold one atomic (indivisible) value, and each row must be unique.
emp_id | name   | phone_numbers
-------|--------|---------------
1      | Alice  | 12345, 67890
Correct =>
emp_id | name   | phone_number
-------|--------|-------------
1      | Alice  | 12345
1      | Alice  | 67890

or diff table for phone number with emp id 

ğŸ”¹ 2NF: Second Normal Form
Rule: Table must be in 1NF, and all non-key columns must depend on the whole primary key.
ğŸ§  Applies only if there's a composite primary key (a key made of two or more columns).
(emp_id, course_id) â†’ marks, student_name, course_name
student_name depends only on emp_id
course_name depends only on course_id
â›” This violates 2NF. Solution: break into 3 tables â€” Student, Course, and Enrollment.
ğŸ‘‰ Your schema has simple primary keys, so you're already satisfying 2NF.

3NF: Third Normal Form
Rule: Table must be in 2NF, and no transitive dependencies (i.e., a non-key column should not depend on another non-key column).
emp_id | name | dept_id | dept_name
Here, dept_name depends on dept_id, not directly on emp_id.
âœ… Solution: move dept_name to a Department table:
Department: dept_id â†’ dept_name
Employee: emp_id â†’ dept_id
ğŸ‘‰ Your schema does this already with Department and Salary tables â€” so âœ… 3NF is satisfied.

 Scenario: University Course Enrollment
âŒ Initial Table (Not in 3NF)
| student\_id | student\_name | course\_id | course\_name | instructor\_name |
| ----------- | ------------- | ---------- | ------------ | ---------------- |
| 1           | Alice         | CSE101     | DBMS         | Dr. Kapoor       |
| 2           | Bob           | CSE101     | DBMS         | Dr. Kapoor       |
| 3           | Charlie       | CSE102     | Networks     | Dr. Rao          |
student_name depends only on student_id â†’ okay.

course_name and instructor_name depend on course_id, not directly on the primary key (student_id, course_id).
| student\_id | student\_name |
| ----------- | ------------- |
| 1           | Alice         |
| 2           | Bob           |
| 3           | Charlie       |

| course\_id | course\_name | instructor\_name |
| ---------- | ------------ | ---------------- |
| CSE101     | DBMS         | Dr. Kapoor       |
| CSE102     | Networks     | Dr. Rao          |

| student\_id | course\_id |
| ----------- | ---------- |
| 1           | CSE101     |
| 2           | CSE101     |
| 3           | CSE102     |

â“ Can we put course_id directly in the student table instead of creating an Enrollment table?
No, we should not â€” if a student can enroll in more than one course, then you must use a separate Enrollment table.

If you add course_id directly in the student table, it assumes:

One student = One course
Which is not true in real-life scenarios.
| student\_id | student\_name | course\_id |
| ----------- | ------------- | ---------- |
| 1           | Alice         | CSE101     |
| 1           | Alice         | CSE102     |
Now youâ€™re repeating Alice twice. Thatâ€™s data duplication, which leads to:

Redundancy
Anomalies during update/delete
Violation of 1NF (atomicity)
âœ… Proper Way: Use an Enrollment Table
A separate Enrollment table handles the many-to-many relationship:
A student can enroll in many courses
A course can have many students

How to separate:

If column B depends on column A, and column A depends on the primary key, then B is transitively dependent.
Move B into a new table with A as its primary key.


# composite key:
CREATE TABLE EmployeePhoneNumbers (
    emp_id INTEGER,
    phone_number TEXT,
    PRIMARY KEY (emp_id, phone_number)
);


